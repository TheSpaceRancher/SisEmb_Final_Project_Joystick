#include <18F4550.h>

#fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN, XT
#use delay(clock=48000000)

#include <pic18_usb.h>
#include <joy_control.h>
#include "usb_desc_joystick.h"
#include <usb.c>

#define JOY_AXIS_X 0
#define JOY_AXIS_Y 1

#define LED_RED PIN_B5
#define LED_GREEN PIN_B6
#define LED_BLUE PIN_B7

typedef struct buttons_state {
   int8 button_joystick;
   int8 button_RB;
   int8 button_LB;
   int8 button_Y;
   int8 button_B;
   int8 button_A;
   int8 button_X;
   int8 button_Up;
   int8 button_Left;
   int8 button_Right;
   int8 button_Down;
} buttons_state;

   buttons_state read_Buttons(){
   buttons_state reading;
   /* return boolean 0/1 for joystick button to simplify edge detection */
   reading.button_joystick = input(PIN_B4)? 1 : 0;
   reading.button_RB = input(PIN_D4);
   reading.button_LB = input(PIN_D5);
   reading.button_Y = input(PIN_D0);
   reading.button_B = input(PIN_D1);
   reading.button_A = input(PIN_D2);
   reading.button_X = input(PIN_D3);
   reading.button_Up = input(PIN_B0);
   reading.button_Left = input(PIN_B1);
   reading.button_Right = input(PIN_B2);
   reading.button_Down = input(PIN_B3);
   return reading;
}


int8 adc_offset(int8 channel){
   int i;
   int32 sum = 0;
   for(i=0;i<8;i++){
      set_adc_channel(channel);
      delay_us(20);
      sum += read_adc();
      delay_ms(5);
   }
   return (int8)(((sum / 8) * 255) / 1023);
}

int8 read_joystick(int8 channel, int8 offset){
   set_adc_channel(channel);
   delay_us(20);
   
   int16 adc = read_adc();
   adc = ((adc*255) / 1023)- offset;
   return (int8)adc;
}

void main()
{
   usb_init_cs();

   int8 data[4];

   int8 moveX = 0;
   int8 moveY = 0;

   int8 offsetX = 128;
   int8 offsetY = 128;

   int8 mode = 0;
   
   buttons_state buttons;
   int8 last_button_joystick = 0; /* for edge detection (toggle) */
   
   setup_adc_ports(AN0_TO_AN1_ANALOG);
   setup_adc(ADC_CLOCK_INTERNAL);

   set_tris_a(0b00000011);
   set_tris_b(0b00011111);
   output_b(0b00000000); 
   set_tris_d(0b00111111); 

   offsetX = adc_offset(0);
   offsetY = adc_offset(1);

   output_high(LED_RED);

   while(TRUE)
   {
      usb_task();

      if(usb_enumerated()){

         buttons = read_Buttons();
         /* TEST: fuerza el botÃ³n A presionado para pruebas */
         buttons.button_A = 1;

         /* Toggle mode on button rising edge (debounced) */
         if(buttons.button_joystick && !last_button_joystick){
            /* small debounce */
            delay_ms(20);
            if(input(PIN_B4)){
               mode = !mode;
            }
         }
         last_button_joystick = buttons.button_joystick;

         /* Update LEDs to reflect mode */
         if(mode){
            output_high(LED_GREEN);  /* joystick */
            output_low(LED_BLUE);
         } else {
            output_low(LED_GREEN);
            output_high(LED_BLUE);   /* mouse */
         }

         /* Build standard gamepad mapping:
            byte0 bits: B0=A, B1=B, B2=X, B3=Y, B4=LB, B5=RB, B6=StickPress, B7=unused
            byte1: X axis (signed)
            byte2: Y axis (signed)
            byte3: Hat (0..7 directions, 8 = neutral)
         */
         int8 btnmask = 0;
         if(buttons.button_A) btnmask |= (1 << 0); /* A */
         if(buttons.button_B) btnmask |= (1 << 1); /* B */
         if(buttons.button_X) btnmask |= (1 << 2); /* X */
         if(buttons.button_Y) btnmask |= (1 << 3); /* Y */
         if(buttons.button_LB) btnmask |= (1 << 4); /* LB */
         if(buttons.button_RB) btnmask |= (1 << 5); /* RB */
         if(buttons.button_joystick) btnmask |= (1 << 6); /* Stick press */

         /* D-pad -> hat mapping
            0: up
            1: up-right
            2: right
            3: down-right
            4: down
            5: down-left
            6: left
            7: up-left
            8: neutral (no direction)
         */
         int8 hat = 8; /* neutral by default */
         int up = buttons.button_Up;
         int down = buttons.button_Down;
         int left = buttons.button_Left;
         int right = buttons.button_Right;

         if(up && right){ hat = 1; }
         else if(right && down){ hat = 3; }
         else if(down && left){ hat = 5; }
         else if(left && up){ hat = 7; }
         else if(up) { hat = 0; }
         else if(right) { hat = 2; }
         else if(down) { hat = 4; }
         else if(left) { hat = 6; }

         if(mode == 1){
            /* Joystick mode: send full gamepad report */
            data[0] = btnmask;
            data[1] = read_joystick(JOY_AXIS_X, offsetX);
            data[2] = read_joystick(JOY_AXIS_Y, offsetY);
            data[3] = hat; /* hat 0..7, 8 neutral */
         } else {
            /* Mouse mode: map controls to mouse report
               data[0] = buttons (left/middle/right)
               data[1] = X relative (small)
               data[2] = Y relative (small)
               data[3] = wheel relative (small)
            */
            int8 m_buttons = 0;
            /* Map A -> left click, B -> right click, X -> middle click */
            if(buttons.button_A) m_buttons |= 0x01; /* left */
            if(buttons.button_B) m_buttons |= 0x02; /* right */
            if(buttons.button_X) m_buttons |= 0x04; /* middle */

            /* Read raw axes and scale down to smaller relative motion */
            int8 rawX = read_joystick(JOY_AXIS_X, offsetX);
            int8 rawY = read_joystick(JOY_AXIS_Y, offsetY);
            /* Reduce sensitivity so cursor doesn't jump too far */
            int8 moveX_small = rawX / 6; /* tune divisor as needed */
            int8 moveY_small = rawY / 6;

            /* Wheel: use D-pad up/down for wheel steps, small increments */
            int8 wheel = 0;
            if(up && !down) wheel = 1;
            else if(down && !up) wheel = -1;

            data[0] = m_buttons;
            data[1] = moveX_small;
            data[2] = moveY_small;
            data[3] = wheel;
         }

         usb_put_packet(1, data, 4, USB_DTS_TOGGLE);
      }
      delay_ms(500);
   }
}
