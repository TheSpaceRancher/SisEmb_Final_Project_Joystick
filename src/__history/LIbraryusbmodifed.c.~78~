#include <18F4550.h>

#fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN, XT
#use delay(clock=48000000)

#include <pic18_usb.h>
#include <joy_control.h>
#include <usb.c>

#define JOY_AXIS_X 0
#define JOY_AXIS_Y 1

#define LED_RED PIN_B5
#define LED_GREEN PIN_B6
#define LED_BLUE PIN_B7

typedef struct buttons_state {
   int8 button_joystick;
   int8 button_RB;
   int8 button_LB;
   int8 button_Y;
   int8 button_B;
   int8 button_A;
   int8 button_X;
   int8 button_Up;
   int8 button_Left;
   int8 button_Right;
   int8 button_Down;
} buttons_state;

buttons_state read_Buttons(){
   buttons_state reading;
   reading.button_joystick = input(PIN_B4)? 2 : 0;
   reading.button_RB = input(PIN_D4);
   reading.button_LB = input(PIN_D5);
   reading.button_Y = input(PIN_D0);
   reading.button_B = input(PIN_D1);
   reading.button_A = input(PIN_D2);
   reading.button_X = input(PIN_D3);
   reading.button_Up = input(PIN_B0);
   reading.button_Left = input(PIN_B1);
   reading.button_Right = input(PIN_B2);
   reading.button_Down = input(PIN_B3);
   return reading;
}


int8 adc_offset(int8 channel){
   int i;
   int32 sum = 0;
   for(i=0;i<8;i++){
      set_adc_channel(channel);
      delay_us(20);
      sum += read_adc();
      delay_ms(5);
   }
   return (int8)(((sum / 8) * 255) / 1023);
}

int8 read_joystick(int8 channel, int8 offset){
   set_adc_channel(channel);
   delay_us(20);
   
   int16 adc = read_adc();
   adc = ((adc*255) / 1023)- offset;
   return (int8)adc;
}

void main()
{
   usb_init_cs();

   int8 data[4];

   int8 moveX = 0;
   int8 moveY = 0;

   int8 offsetX = 128;
   int8 offsetY = 128;

   buttons_state buttons;
   
   setup_adc_ports(AN0_AN1); // o el macro que tu CCS soporte
   setup_adc(ADC_CLOCK_INTERNAL);

   set_tris_a(0b00000011);

   /* Configure PORTB: B0..B4 inputs for buttons, B5..B7 outputs for RGB LEDs */
   set_tris_b(0b00011111); /* RB7..RB5 = 0 (outputs), RB4..RB0 = 1 (inputs) */
   output_b(0b00000000); /* clear outputs (turn off LEDs) */

   /* Configure PORTD: D0..D5 inputs for buttons, D6..D7 outputs (unused) */
   set_tris_d(0b00111111); /* RD7..RD6 = 0 (outputs), RD5..RD0 = 1 (inputs) */

   offsetX = adc_offset(0);
   offsetY = adc_offset(1);


   while(TRUE)
   {
     
      usb_task();

      if(usb_enumerated()){

         buttons = read_Buttons();
         // muestra el estado del botÃ³n joystick en LED
         if (input(PIN_B4)) output_high(LED_RED); else output_low(LED_RED);
         delay_ms(200);
         output_low(LED_RED);
         delay_ms(200);
         data[0] = 0;
         data[1] = read_joystick(JOY_AXIS_X, offsetY);
         data[2] = read_joystick(JOY_AXIS_Y, offsetY);
         data[3] = buttons.button_joystick;

         usb_put_packet(1, data, 4, USB_DTS_TOGGLE);
      }
   }
}
