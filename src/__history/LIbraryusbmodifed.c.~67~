#include <18F4550.h>

#fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN, XT
#use delay(clock=48000000)

#include <pic18_usb.h>
#include <joy_control.h>
#include <usb.c>

/* Lee 'samples' lecturas del ADC en 'channel' y devuelve el promedio */
int16 adc_read_average(int8 channel, int8 samples){
   int i;
   int32 sum = 0;
   int16 v;
   for(i=0;i<samples;i++){
      set_adc_channel(channel);
      delay_us(20);
      v = read_adc();
      sum += v;
      delay_ms(5);
   }
   return (int16)(sum / samples);
}

void main()
{
   usb_init_cs();

   int8 data[4];
   int16 ADCx;            /* ADC raw (10-bit: 0..1023) */
   int8 move = 0;
   int16 delta = 0;
   int16 center8 = 128;   /* offset calibrado en 8-bit space (0..255) */

   setup_adc_ports(All_ANALOG);
   setup_adc(ADC_CLOCK_INTERNAL);

   set_tris_a(0b00000001);

   /* calibraciÃ³n inicial: leer varias muestras (10-bit) y convertir a 8-bit */
   center8 = (adc_read_average(0, 8) * 255) / 1023;
   while(TRUE)
   {
      set_adc_channel(0);
      delay_us(20);
      ADCx = read_adc(); /* 0..1023 (10-bit) */

      /* convertir 10-bit -> 8-bit (0..255) */
      int16 adc8 = (ADCx * 255) / 1023;

      /* usar el centro calibrado (en 8-bit) como offset */
      delta = adc8 - center8; /* rango aprox -128..+127 */
      move = (int8)delta;
      usb_task();

      if(usb_enumerated()){

         data[0] = 0;
         data[1] = move; /* desplazamiento signed -127..+127 (mitad del ADC = 0) */
         data[2] = 0;
         data[3] = 0;

         usb_put_packet(1, data, 4, USB_DTS_TOGGLE);
      }
      delay_ms(50);
   }
}
